// Code generated by mockery v2.7.5. DO NOT EDIT.

package mocks

import (
	artifact "github.com/mittwald/goharbor-client/v3/apiv2/internal/api/client/artifact"
	mock "github.com/stretchr/testify/mock"

	runtime "github.com/go-openapi/runtime"
)

// MockArtifactClientService is an autogenerated mock type for the ClientService type
type MockArtifactClientService struct {
	mock.Mock
}

// AddLabel provides a mock function with given fields: params, authInfo, opts
func (_m *MockArtifactClientService) AddLabel(params *artifact.AddLabelParams, authInfo runtime.ClientAuthInfoWriter, opts ...artifact.ClientOption) (*artifact.AddLabelOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *artifact.AddLabelOK
	if rf, ok := ret.Get(0).(func(*artifact.AddLabelParams, runtime.ClientAuthInfoWriter, ...artifact.ClientOption) *artifact.AddLabelOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*artifact.AddLabelOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*artifact.AddLabelParams, runtime.ClientAuthInfoWriter, ...artifact.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CopyArtifact provides a mock function with given fields: params, authInfo, opts
func (_m *MockArtifactClientService) CopyArtifact(params *artifact.CopyArtifactParams, authInfo runtime.ClientAuthInfoWriter, opts ...artifact.ClientOption) (*artifact.CopyArtifactCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *artifact.CopyArtifactCreated
	if rf, ok := ret.Get(0).(func(*artifact.CopyArtifactParams, runtime.ClientAuthInfoWriter, ...artifact.ClientOption) *artifact.CopyArtifactCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*artifact.CopyArtifactCreated)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*artifact.CopyArtifactParams, runtime.ClientAuthInfoWriter, ...artifact.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTag provides a mock function with given fields: params, authInfo, opts
func (_m *MockArtifactClientService) CreateTag(params *artifact.CreateTagParams, authInfo runtime.ClientAuthInfoWriter, opts ...artifact.ClientOption) (*artifact.CreateTagCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *artifact.CreateTagCreated
	if rf, ok := ret.Get(0).(func(*artifact.CreateTagParams, runtime.ClientAuthInfoWriter, ...artifact.ClientOption) *artifact.CreateTagCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*artifact.CreateTagCreated)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*artifact.CreateTagParams, runtime.ClientAuthInfoWriter, ...artifact.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteArtifact provides a mock function with given fields: params, authInfo, opts
func (_m *MockArtifactClientService) DeleteArtifact(params *artifact.DeleteArtifactParams, authInfo runtime.ClientAuthInfoWriter, opts ...artifact.ClientOption) (*artifact.DeleteArtifactOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *artifact.DeleteArtifactOK
	if rf, ok := ret.Get(0).(func(*artifact.DeleteArtifactParams, runtime.ClientAuthInfoWriter, ...artifact.ClientOption) *artifact.DeleteArtifactOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*artifact.DeleteArtifactOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*artifact.DeleteArtifactParams, runtime.ClientAuthInfoWriter, ...artifact.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTag provides a mock function with given fields: params, authInfo, opts
func (_m *MockArtifactClientService) DeleteTag(params *artifact.DeleteTagParams, authInfo runtime.ClientAuthInfoWriter, opts ...artifact.ClientOption) (*artifact.DeleteTagOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *artifact.DeleteTagOK
	if rf, ok := ret.Get(0).(func(*artifact.DeleteTagParams, runtime.ClientAuthInfoWriter, ...artifact.ClientOption) *artifact.DeleteTagOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*artifact.DeleteTagOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*artifact.DeleteTagParams, runtime.ClientAuthInfoWriter, ...artifact.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAddition provides a mock function with given fields: params, authInfo, opts
func (_m *MockArtifactClientService) GetAddition(params *artifact.GetAdditionParams, authInfo runtime.ClientAuthInfoWriter, opts ...artifact.ClientOption) (*artifact.GetAdditionOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *artifact.GetAdditionOK
	if rf, ok := ret.Get(0).(func(*artifact.GetAdditionParams, runtime.ClientAuthInfoWriter, ...artifact.ClientOption) *artifact.GetAdditionOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*artifact.GetAdditionOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*artifact.GetAdditionParams, runtime.ClientAuthInfoWriter, ...artifact.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetArtifact provides a mock function with given fields: params, authInfo, opts
func (_m *MockArtifactClientService) GetArtifact(params *artifact.GetArtifactParams, authInfo runtime.ClientAuthInfoWriter, opts ...artifact.ClientOption) (*artifact.GetArtifactOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *artifact.GetArtifactOK
	if rf, ok := ret.Get(0).(func(*artifact.GetArtifactParams, runtime.ClientAuthInfoWriter, ...artifact.ClientOption) *artifact.GetArtifactOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*artifact.GetArtifactOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*artifact.GetArtifactParams, runtime.ClientAuthInfoWriter, ...artifact.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVulnerabilitiesAddition provides a mock function with given fields: params, authInfo, opts
func (_m *MockArtifactClientService) GetVulnerabilitiesAddition(params *artifact.GetVulnerabilitiesAdditionParams, authInfo runtime.ClientAuthInfoWriter, opts ...artifact.ClientOption) (*artifact.GetVulnerabilitiesAdditionOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *artifact.GetVulnerabilitiesAdditionOK
	if rf, ok := ret.Get(0).(func(*artifact.GetVulnerabilitiesAdditionParams, runtime.ClientAuthInfoWriter, ...artifact.ClientOption) *artifact.GetVulnerabilitiesAdditionOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*artifact.GetVulnerabilitiesAdditionOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*artifact.GetVulnerabilitiesAdditionParams, runtime.ClientAuthInfoWriter, ...artifact.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListArtifacts provides a mock function with given fields: params, authInfo, opts
func (_m *MockArtifactClientService) ListArtifacts(params *artifact.ListArtifactsParams, authInfo runtime.ClientAuthInfoWriter, opts ...artifact.ClientOption) (*artifact.ListArtifactsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *artifact.ListArtifactsOK
	if rf, ok := ret.Get(0).(func(*artifact.ListArtifactsParams, runtime.ClientAuthInfoWriter, ...artifact.ClientOption) *artifact.ListArtifactsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*artifact.ListArtifactsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*artifact.ListArtifactsParams, runtime.ClientAuthInfoWriter, ...artifact.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTags provides a mock function with given fields: params, authInfo, opts
func (_m *MockArtifactClientService) ListTags(params *artifact.ListTagsParams, authInfo runtime.ClientAuthInfoWriter, opts ...artifact.ClientOption) (*artifact.ListTagsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *artifact.ListTagsOK
	if rf, ok := ret.Get(0).(func(*artifact.ListTagsParams, runtime.ClientAuthInfoWriter, ...artifact.ClientOption) *artifact.ListTagsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*artifact.ListTagsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*artifact.ListTagsParams, runtime.ClientAuthInfoWriter, ...artifact.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveLabel provides a mock function with given fields: params, authInfo, opts
func (_m *MockArtifactClientService) RemoveLabel(params *artifact.RemoveLabelParams, authInfo runtime.ClientAuthInfoWriter, opts ...artifact.ClientOption) (*artifact.RemoveLabelOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *artifact.RemoveLabelOK
	if rf, ok := ret.Get(0).(func(*artifact.RemoveLabelParams, runtime.ClientAuthInfoWriter, ...artifact.ClientOption) *artifact.RemoveLabelOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*artifact.RemoveLabelOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*artifact.RemoveLabelParams, runtime.ClientAuthInfoWriter, ...artifact.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetTransport provides a mock function with given fields: transport
func (_m *MockArtifactClientService) SetTransport(transport runtime.ClientTransport) {
	_m.Called(transport)
}
